## B站视频 BV1ce411u7qP

![image](https://github.com/ethan686/books/assets/73508499/d621d5d7-2142-4199-9fa6-b20902c04a2f)

如图，对最下面一行的数组，进行求和以及更新某一个值的操作。更新容易，但是再对某一段区间进行求和的时候，需要进行遍历。
这里采用线段树的思想，将原来的数组，两两求和 构建一个新的数组(倒数第二排)。这样更新的时候需要更新两次，但是求和的时候，
运算量直接下降了一倍。在继续两两求和，这样更新最多到log级别，求和的运算量指数下降，最后也是log级别的运算量。

经过上述的优化之后，我们使用了 n + n/2 + n/4 + ... + 1的额外的空间，实现了log级别的一个算法，cool。

但是其实在不断的两两求和过程中，部分元素是无用的了。例如，倒数第二排的第二个元素5，在求前两个元素和 直接是14，前三个元素
直接14 + 1，前四个元素和 直接19，前5个元素和 19 +5.也就是说这个5是totally useless。将所有辅助数组中的所有无用的元素都去掉之后，剩余的元素 刚好只有n个了。
(怎么确定哪些元素 是真的需要保留下来的元素呢？？)

所有层，甚至包括第一层。第偶数个元素都是没有的，可以去掉。这样去掉之后，只有n个元素。这个新的n个元素单独储存，就是
一个树状数组。求和的时候找到对应的区间加起来就可以，修改元素的时候，修改所有包含改元素的区间。
![image](https://github.com/ethan686/books/assets/73508499/3ea66937-7e0a-4511-b62d-daa04faeed6c)

这样操作之后，树状数组中的一个元素，实际上代表的就是一个区间。第一层区间长度位1，往上都是2的次幂的长度。而且这些元素在树状数组中的下标的lowbit也刚好是对应层数的2次幂。序号为i的数据，刚好包含了lowbit(i)的区间长度，并且区间以i来结尾。

所以计算前14个元素的和  就是 14-lowbit(14) = 12 计算前12个元素的和 加上b[14]就可以。(根据前面的逻辑 b[14]包含两个元素)

至于更新：一个序列b[i]对应正上方的序列，刚好是b[i+lowbit(i)]
